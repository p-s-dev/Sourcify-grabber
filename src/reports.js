import fs from 'fs/promises';
import path from 'path';
import logger from './log.js';

const REPORTS_DIR = 'reports';

/**
 * Report generation utilities
 */
export class ReportManager {
  
  /**
   * Generate summary report for a fetch run
   * @param {Object} runData - Data from the fetch run
   * @returns {Promise<void>}
   */
  async generateSummaryReport(runData) {
    const {
      runId,
      startTime,
      endTime,
      chains,
      totalProcessed,
      totalSuccessful,
      totalFailed,
      newContracts,
      updatedContracts,
      failedContracts
    } = runData;

    const timestamp = new Date().toISOString().split('T')[0];
    const reportFile = path.join(REPORTS_DIR, `summary-${timestamp}.md`);

    await fs.mkdir(REPORTS_DIR, { recursive: true });

    const duration = endTime - startTime;
    const successRate = totalProcessed > 0 ? (totalSuccessful / totalProcessed * 100).toFixed(1) : 0;

    const report = `# Contract Archive Fetch Summary

**Run ID:** ${runId}  
**Date:** ${new Date(startTime).toISOString()}  
**Duration:** ${Math.round(duration / 1000)}s  
**Chains:** ${chains.join(', ')}

## Summary Statistics

- **Total Processed:** ${totalProcessed}
- **Successful:** ${totalSuccessful} (${successRate}%)
- **Failed:** ${totalFailed}
- **New Contracts:** ${newContracts.length}
- **Updated Contracts:** ${updatedContracts.length}

## New Contracts Added

${newContracts.length > 0 ? 
  newContracts.map(c => `- \`${c.address}\` on ${c.chain} (${c.source})`).join('\n') : 
  '_None_'}

## Updated Contracts

${updatedContracts.length > 0 ? 
  updatedContracts.map(c => `- \`${c.address}\` on ${c.chain} (${c.source})`).join('\n') : 
  '_None_'}

## Failed Contracts

${failedContracts.length > 0 ? 
  failedContracts.map(c => `- \`${c.address}\` on ${c.chain}: ${c.error}`).join('\n') : 
  '_None_'}

## Data Sources Used

${this.generateSourcesBreakdown(runData)}

---
*Generated by sourcify-grabber v2.0.0*
`;

    await fs.writeFile(reportFile, report, 'utf8');
    
    logger.info('Summary report generated', { 
      reportFile, 
      runId, 
      totalProcessed, 
      totalSuccessful, 
      totalFailed 
    });

    return reportFile;
  }

  /**
   * Generate sources breakdown for report
   * @param {Object} runData - Run data
   * @returns {string} Sources breakdown
   */
  generateSourcesBreakdown(runData) {
    const sources = {};
    
    [...runData.newContracts, ...runData.updatedContracts].forEach(contract => {
      if (!sources[contract.source]) {
        sources[contract.source] = 0;
      }
      sources[contract.source]++;
    });

    return Object.keys(sources).length > 0 ? 
      Object.entries(sources).map(([source, count]) => `- **${source}:** ${count} contracts`).join('\n') :
      '_No successful fetches_';
  }

  /**
   * Generate machine-readable diff file
   * @param {Object} diffData - Diff data
   * @returns {Promise<string>} Diff file path
   */
  async generateDiffReport(diffData) {
    const timestamp = new Date().toISOString().split('T')[0];
    const diffFile = path.join(REPORTS_DIR, 'diffs', `diff-${timestamp}.json`);

    await fs.mkdir(path.dirname(diffFile), { recursive: true });
    await fs.writeFile(diffFile, JSON.stringify(diffData, null, 2), 'utf8');

    logger.info('Diff report generated', { diffFile });
    return diffFile;
  }

  /**
   * Get overall statistics for all chains
   * @param {Array} chains - Chain names
   * @param {Function} getChainStats - Function to get stats for a chain
   * @returns {Promise<Object>} Overall statistics
   */
  async generateOverallStats(chains, getChainStats) {
    const stats = {
      totalChains: chains.length,
      totalInputAddresses: 0,
      totalArchivedContracts: 0,
      totalPendingContracts: 0,
      chainBreakdown: {},
      sourceBreakdown: {
        sourcify: 0,
        explorer: 0,
        unknown: 0
      },
      lastUpdated: new Date().toISOString()
    };

    for (const chain of chains) {
      const chainStats = await getChainStats(chain);
      stats.totalInputAddresses += chainStats.inputAddresses;
      stats.totalArchivedContracts += chainStats.archivedContracts;
      stats.totalPendingContracts += chainStats.pendingContracts;
      
      stats.chainBreakdown[chain] = chainStats;
      
      // Aggregate source breakdown if available
      if (chainStats.sourceBreakdown) {
        stats.sourceBreakdown.sourcify += chainStats.sourceBreakdown.sourcify || 0;
        stats.sourceBreakdown.explorer += chainStats.sourceBreakdown.explorer || 0;
        stats.sourceBreakdown.unknown += chainStats.sourceBreakdown.unknown || 0;
      }
    }

    return stats;
  }

  /**
   * Generate status report markdown
   * @param {Object} stats - Overall statistics
   * @returns {string} Status report markdown
   */
  generateStatusReport(stats) {
    const completionRate = stats.totalInputAddresses > 0 ? 
      (stats.totalArchivedContracts / stats.totalInputAddresses * 100).toFixed(1) : 0;

    return `# Contract Archive Status Report

**Generated:** ${new Date(stats.lastUpdated).toLocaleString()}

## Overall Statistics

- **Total Chains:** ${stats.totalChains}
- **Total Input Addresses:** ${stats.totalInputAddresses}
- **Total Archived Contracts:** ${stats.totalArchivedContracts}
- **Total Pending Contracts:** ${stats.totalPendingContracts}
- **Completion Rate:** ${completionRate}%

## Data Sources

- **Sourcify:** ${stats.sourceBreakdown.sourcify} contracts
- **Explorer APIs:** ${stats.sourceBreakdown.explorer} contracts
- **Unknown/Other:** ${stats.sourceBreakdown.unknown} contracts

## Chain Breakdown

${Object.entries(stats.chainBreakdown).map(([chain, chainStats]) => `
### ${chain}

- Input addresses: ${chainStats.inputAddresses}
- Archived: ${chainStats.archivedContracts}
- Pending: ${chainStats.pendingContracts}
- Success rate: ${chainStats.inputAddresses > 0 ? 
  (chainStats.archivedContracts / chainStats.inputAddresses * 100).toFixed(1) : 0}%
`).join('')}

---
*Auto-generated status report*
`;
  }

  /**
   * Create run summary data structure
   * @param {Object} options - Run options
   * @returns {Object} Run data structure
   */
  createRunData(options = {}) {
    return {
      runId: options.runId || `run-${Date.now()}`,
      startTime: Date.now(),
      endTime: null,
      chains: options.chains || [],
      totalProcessed: 0,
      totalSuccessful: 0,
      totalFailed: 0,
      newContracts: [],
      updatedContracts: [],
      failedContracts: []
    };
  }

  /**
   * Finalize run data with end time
   * @param {Object} runData - Run data to finalize
   * @returns {Object} Finalized run data
   */
  finalizeRunData(runData) {
    runData.endTime = Date.now();
    return runData;
  }
}

export default new ReportManager();